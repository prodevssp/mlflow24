{"version":3,"file":"enzyme.js","sources":["../../src/test-utils/enzyme/utils.ts","../../src/test-utils/enzyme/selectEvent.ts","../../src/test-utils/enzyme/table.ts","../../src/test-utils/enzyme/index.ts"],"sourcesContent":["// eslint-disable-next-line @databricks/no-restricted-imports-regexp\nimport type { ReactWrapper } from 'enzyme';\nimport { act } from 'react-dom/test-utils';\n\ninterface QueryOptions {\n  /** Whether to trim the whitespace from DOM text using `String.prototype.trim` */\n  trim?: boolean;\n}\n\n/**\n * Finds a single element that contains the specified text in the wrapper. If\n * there are 0 or more than 1 element that contains the specified text, an error\n * is thrown. Returns the element in an enzyme wrapper.\n */\nexport function findByText<P, S, C>(\n  wrapper: ReactWrapper<P, S, C>,\n  text: string | RegExp,\n  queryOptions?: QueryOptions,\n) {\n  const newWrappers = findAllByText<P, S, C>(wrapper, text, queryOptions);\n  if (newWrappers.length !== 1) {\n    throw new Error(\n      `Expected to find 1 node but found ${newWrappers.length} nodes for text \"${text}\".\\n${wrapper.debug()}`,\n    );\n  }\n  return newWrappers[0];\n}\n\n/**\n * Finds all elements that contain the specified text. To avoid duplicate results,\n * only the parents of text nodes are returned.\n */\nexport function findAllByText<P, S, C>(\n  wrapper: ReactWrapper<P, S, C>,\n  text: string | RegExp,\n  { trim = false }: QueryOptions = {},\n) {\n  const textNodes = wrapper.findWhere((n) => {\n    if (typeof n.type() !== 'string' || n.getDOMNode().children.length !== 0) {\n      return false;\n    }\n\n    let nodeText = n.text();\n    if (trim) {\n      nodeText = nodeText.trim();\n    }\n\n    return typeof text === 'string' ? nodeText === text : text.test(nodeText);\n  });\n  const newWrappers = textNodes.map((n) => {\n    if (n.name() === 'FormattedMessage') {\n      // Try not to return FormattedMessage since it breaks `simulate` due to a bug in `enzyme-adapter-react-17`\n      // Similar to https://github.com/wojtekmaj/enzyme-adapter-react-17/issues/45\n      const formattedMessageParents = n.parents();\n      return formattedMessageParents.length > 0 ? formattedMessageParents.first() : n;\n    } else {\n      return n;\n    }\n  });\n  return newWrappers;\n}\n\n// We need to keep ref to original setTimeout to avoid SinonJS fake timers if enabled\nconst originalSetTimeout = window.setTimeout;\n\n/**\n * This is so the stack trace the developer sees is one that's\n * closer to their code (because async stack traces are hard to follow).\n *\n * The code is taken from\n * https://github.com/testing-library/dom-testing-library/blob/f7b5c33c44632fba\n * 1579cb44f9f175be1ec46087/src/wait-for.js#L15-L19\n */\nfunction copyStackTrace(target: Error, source: Error) {\n  // eslint-disable-next-line no-param-reassign\n  target.stack = source.stack!.replace(source.message, target.message);\n}\n\ninterface WaitForOptions {\n  interval?: number;\n  stackTraceError?: Error;\n  timeout?: number;\n}\n\n/**\n * Run an expectation until it succeeds or reaches the timeout. The timeout of 1500ms\n * is chosen to be under the default Karma test timeout of 2000ms. This function will\n * not work properly if fake timers are being used (since it expects the real setTimeout).\n *\n * The code is taken from\n * https://github.com/TheBrainFamily/wait-for-expect/blob/master/src/index.ts,\n * with slight modifications to support Karma (instead of Jest).\n *\n *\n * Example\n * The <App /> component does not render the header synchronously.\n * Therefore, we cannot check that the wrapper's text is equal to the string\n * immediately--this assertion will fail and cause the test to fail. To\n * remediate this issue, we can run the expectation until it succeeds:\n *\n * function App() {\n *   const [value, setValue] = useState(null);\n *   useEffect(() => {\n *     const timeoutId = setTimeout(() => setValue(\"some value\"), 100);\n *     return () => clearTimeout(timeoutId);\n *   }, []);\n *   return value === null ? null : <h1>The value is: {value}</h1>;\n * }\n *\n * it('renders value', async () => {\n *   const wrapper = mount(<App />);\n *   await waitFor(() =>\n *     wrapper.update();\n *     expect(wrapper.text()).to.equal(\"The value is: some value\")\n *   );\n * });\n */\nfunction _waitFor<T>(\n  f: () => T | Promise<T>,\n  { interval = 50, stackTraceError, timeout = 1500 }: WaitForOptions = {},\n): Promise<T> {\n  const maxTries = Math.ceil(timeout / interval);\n  let tries = 0;\n  return new Promise((resolve, reject) => {\n    const rejectOrRerun = (error: Error) => {\n      if (tries > maxTries) {\n        if (stackTraceError !== undefined) {\n          copyStackTrace(error, stackTraceError);\n        }\n        reject(error);\n        return;\n      }\n      originalSetTimeout(runExpectation, interval);\n    };\n\n    function runExpectation() {\n      tries += 1;\n      try {\n        Promise.resolve(f()).then(resolve).catch(rejectOrRerun);\n      } catch (error) {\n        // @ts-expect-error ts-migrate(2571) Object is of type 'unknown'\n        rejectOrRerun(error);\n      }\n    }\n\n    originalSetTimeout(runExpectation, 0);\n  });\n}\n\n/**\n * Wraps `_waitFor` in React's `act` testing utility. Used when the React component\n * updates during the execution of the callback (either because of indirect effects\n * being run or because of direct requests to update the component, like wrapper.update).\n * Prevents updates related to the callback from being affected by other updates\n * and more closely mimics how React runs in the browser. See\n * https://reactjs.org/docs/test-utils.html#act for more info on `act`.\n */\nexport async function waitFor<T>(callback: () => T | Promise<T>, options?: WaitForOptions): Promise<T> {\n  let result: T | Promise<T>;\n  // See https://github.com/testing-library/dom-testing-library/blob/f7b5c33c44\n  // 632fba1579cb44f9f175be1ec46087/src/wait-for.js#L182-L184\n  const stackTraceError = new Error('STACK_TRACE_ERROR');\n\n  await act(async () => {\n    result = await _waitFor(callback, { stackTraceError, ...options });\n  });\n\n  // @ts-expect-error: either `waitFor` will throw or `result` will be assigned\n  return result;\n}\n\n/**\n * Finds all elements (that are rendered in the DOM) in `wrapper` that have an explicit\n * role of `role` specified. This is similar to `getAllByRole` from @testing-library/react\n * but is much simpler because of the shortcomings of Enzyme's API.\n */\nexport function findAllByRole(wrapper: ReactWrapper, role: string): ReactWrapper[] {\n  return wrapper\n    .find(`[role=\"${role}\"]`)\n    .hostNodes()\n    .map((n) => n);\n}\n","// eslint-disable-next-line @databricks/no-restricted-imports-regexp\nimport type { ReactWrapper } from 'enzyme';\n\nimport { selectClasses } from '../common';\nimport { findByText, waitFor } from './utils';\n\n/**\n * Clicks on the \"Clear\" button. In order for this function to work properly,\n * the `allowClear` prop must be set to `true`.\n */\nexport function clearAll(getSelect: () => ReactWrapper): void {\n  getSelect().find(`.${selectClasses.clear}`).hostNodes().simulate('mousedown');\n}\n\n/**\n * Closes the dropdown menu for the <Select/> by clicking. Will throw an error if\n * the menu is already closed or if the menu is unable to be closed.\n */\nexport async function closeMenu(getSelect: () => ReactWrapper): Promise<void> {\n  if (!getSelect().find(`.${selectClasses.open}`).exists()) {\n    throw new Error(`Select is already closed\\n${getSelect().debug()}`);\n  }\n  getSelect().find(`.${selectClasses.selector}`).simulate('mousedown');\n  await waitFor(() => {\n    const select = getSelect();\n    if (select.find(`.${selectClasses.open}`).exists()) {\n      throw new Error(`Select did not close\\n${select.debug()}`);\n    }\n  });\n}\n\n/**\n * Returns a string concatenating the labels for all selected options.\n */\nexport function getLabelText(getSelect: () => ReactWrapper): string {\n  // Trim the text to avoid weird whitespace issues non-label elements being added.\n  // For example, the input mirror is an empty span with some whitespace that is\n  // nested under the selector but does not show up in the label text.\n  return getSelect().find(`.${selectClasses.selector}`).text().trim();\n}\n\n/**\n * Selects options from the dropdown menu for a <Select/> component with `mode=\"multiple\"`.\n * The provided strings must match the option labels exactly. There is a known\n * limitation for lists that are extremely long because AntD virtualizes the\n * options so not all may options may be rendered in the DOM. If this is causing\n * you issues, please let #help-frontend know.\n */\nexport async function multiSelect(getSelect: () => ReactWrapper, options: string[]): Promise<void> {\n  await openMenu(getSelect);\n  options.forEach((option) => {\n    findByText(getSelect().find(`.${selectClasses.list}`), option).simulate('click');\n  });\n  // Close the menu to indicate that selection has finished\n  await closeMenu(getSelect);\n}\n\n/**\n * Selects options from the dropdown menu for a <Select/> component without a\n * mode. The provided string must match an option label exactly. There is a known\n * limitation for lists that are extremely long because AntD virtualizes the\n * options so not all may options may be rendered in the DOM. If this is causing\n * you issues, please let #help-frontend know.\n */\nexport async function singleSelect(getSelect: () => ReactWrapper, option: string): Promise<void> {\n  await openMenu(getSelect);\n  findByText(getSelect().find(`.${selectClasses.list}`), option).simulate('click');\n  // Menu automatically closes for a single <Select/> (no mode=\"multiple\")\n}\n\n/**\n * Opens the dropdown menu for the <Select/> by clicking. Will throw an error if\n * the menu is already opened or if the menu is unable to be opened.\n */\nexport async function openMenu(getSelect: () => ReactWrapper): Promise<void> {\n  if (getSelect().find(`.${selectClasses.open}`).exists()) {\n    throw new Error(`Select is already open\\n${getSelect().debug()}`);\n  }\n  getSelect().find(`.${selectClasses.selector}`).simulate('mousedown');\n  await waitFor(() => {\n    const select = getSelect();\n    if (!select.find(`.${selectClasses.open}`).exists()) {\n      throw new Error(`Select did not open\\n${select.debug()}`);\n    }\n  });\n}\n\n/**\n * Opens the dropdown menu, finds all of the options in the dropdown, closes\n * the menu, and returns a list of the text of each option in order.\n */\nexport async function getAllOptions(getSelect: () => ReactWrapper): Promise<string[]> {\n  await openMenu(getSelect);\n  const options = getSelect()\n    .find(`.${selectClasses.list}`)\n    .find(`.${selectClasses.option}`)\n    .map((option) => option.text());\n  await closeMenu(getSelect);\n  return options;\n}\n","// eslint-disable-next-line @databricks/no-restricted-imports-regexp\nimport type { ReactWrapper } from 'enzyme';\n\nimport type { GetTableRowByCellTextOptions, TableRows } from '../common';\nimport { createMarkdownTable } from '../common';\nimport { findAllByRole, findByText } from './utils';\n\n/**\n * Returns the table row that contains the specified `cellText`. The `cellText`\n * must be in the column with name `columnHeaderName` if it is specified. Otherwise,\n * the `cellText` must be in the first column. Throws an error if either multiple\n * rows or no rows can be found that match the given options. Also throws an error\n * if the column with name `columnHeaderName` cannot be found.\n *\n * @param tableWrapper The ReactWrapper containing the table to query in.\n * @param cellText The cell text that uniquely identifies the row.\n * @param columnHeaderName The name of the column to search the text for. If not provided,\n * the first column will be used.\n */\nexport function getTableRowByCellText(\n  tableWrapper: ReactWrapper,\n  cellText: string,\n  { columnHeaderName }: GetTableRowByCellTextOptions = {},\n): ReactWrapper {\n  let columnHeaderIndex: number;\n  if (columnHeaderName === undefined) {\n    columnHeaderIndex = 0;\n  } else {\n    const columnHeaders = findAllByRole(tableWrapper, 'columnheader');\n    columnHeaderIndex = columnHeaders.findIndex((n) => {\n      try {\n        findByText(n, columnHeaderName);\n        return true;\n      } catch {\n        return false;\n      }\n    });\n    if (columnHeaderIndex === -1) {\n      throw new Error(`Unable to find a column with name \"${columnHeaderName}\"\\n${tableWrapper.debug()}`);\n    }\n  }\n\n  const matchingRows = findAllByRole(tableWrapper, 'row')\n    // Skip first row (table header)\n    .slice(1)\n    .filter((row) => {\n      const cells = findAllByRole(row, 'cell');\n      const cell = cells[columnHeaderIndex];\n      try {\n        findByText(cell, cellText);\n        return true;\n      } catch {\n        return false;\n      }\n    });\n\n  if (matchingRows.length === 0) {\n    throw new Error(\n      `Unable to find a table row with text \"${cellText}\" in the column \"${columnHeaderName}\"\\n${tableWrapper.debug()}`,\n    );\n  }\n\n  if (matchingRows.length > 1) {\n    throw new Error(\n      `Found multiple table rows with text \"${cellText}\" in the column \"${columnHeaderName}\"\\n${tableWrapper.debug()}`,\n    );\n  }\n\n  return matchingRows[0].hostNodes();\n}\n\n/**\n * Converts a Du Bois table to a markdown table string. This means that each cell\n * is separated by a pipe (including the edges), the header row is on its own line\n * at the top, each data row is on its own line below, and the header row is separated\n * by a row of dashes from the data rows. This is useful for checking table contents\n * in tests.\n *\n * @param tableWrapper The ReactWrapper containing the table to query in.\n *\n * @example\n * The HTML table:\n * ```jsx\n *   <Table>\n *     <TableRow isHeader>\n *       <TableHeader>Name</TableHeader>\n *       <TableHeader>Fruit</TableHeader>\n *     </TableRow>\n *     <TableRow>\n *       <TableCell>Alice</TableCell>\n *       <TableCell>Apple</TableCell>\n *     </TableRow>\n *     <TableRow>\n *       <TableCell>Brady</TableCell>\n *       <TableCell>Banana</TableCell>\n *     </TableRow>\n *   </Table>\n * ```\n *\n * The Markdown table:\n * ```md\n *   | Name | Fruit |\n *   | --- | --- |\n *   | Alice | Apple |\n *   | Brady | Banana |\n * ```\n */\nexport function toMarkdownTable(tableWrapper: ReactWrapper): string {\n  const { bodyRows, headerRow } = getTableRows(tableWrapper);\n  const columns = findAllByRole(headerRow, 'columnheader').map((column) => column.text());\n  const rows = bodyRows.map((row) => findAllByRole(row, 'cell').map((cell) => cell.text()));\n  return createMarkdownTable(columns, rows);\n}\n\n/**\n * Returns the header row and all body rows (non-header rows) in order. Assumes that the\n * `tableWrapper` has a single header row (as the first row) and the rest of the rows are\n * body rows.\n *\n * @param tableWrapper The ReactWrapper containing the table to query in.\n */\nexport function getTableRows(tableWrapper: ReactWrapper): TableRows<ReactWrapper> {\n  const [firstRow, ...restRows] = findAllByRole(tableWrapper, 'row');\n  return {\n    bodyRows: restRows,\n    headerRow: firstRow,\n  };\n}\n","// eslint-disable-next-line @databricks/no-restricted-imports-regexp\nimport type { ReactWrapper } from 'enzyme';\n\nexport * as selectEvent from './selectEvent';\n\nexport * from './table';\n\n/**\n * Open a dropdown menu by simulating a pointerDown event on the dropdown button.\n *\n * @param dropdownButton - The Dropdown Trigger button that opens the menu when clicked.\n */\nexport const openDropdownMenu = (dropdownButton: ReactWrapper) => {\n  dropdownButton.hostNodes().simulate('pointerDown', { button: 0, ctrlKey: false });\n};\n"],"names":["findByText","wrapper","text","queryOptions","newWrappers","findAllByText","length","Error","debug","trim","arguments","undefined","textNodes","findWhere","n","type","getDOMNode","children","nodeText","test","map","name","formattedMessageParents","parents","first","originalSetTimeout","window","setTimeout","copyStackTrace","target","source","stack","replace","message","_waitFor","f","interval","stackTraceError","timeout","maxTries","Math","ceil","tries","Promise","resolve","reject","rejectOrRerun","error","runExpectation","then","catch","waitFor","callback","options","result","act","findAllByRole","role","find","hostNodes","clearAll","getSelect","selectClasses","clear","simulate","closeMenu","open","exists","selector","select","getLabelText","multiSelect","openMenu","forEach","option","list","singleSelect","getAllOptions","getTableRowByCellText","tableWrapper","cellText","columnHeaderName","columnHeaderIndex","columnHeaders","findIndex","matchingRows","slice","filter","row","cells","cell","toMarkdownTable","bodyRows","headerRow","getTableRows","columns","column","rows","createMarkdownTable","firstRow","restRows","openDropdownMenu","dropdownButton","button","ctrlKey"],"mappings":"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"}